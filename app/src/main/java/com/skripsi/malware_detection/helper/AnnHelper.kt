package com.skripsi.malware_detection.helper

import android.content.Context
import android.content.res.AssetManager
import android.util.Log
import com.google.android.gms.tflite.client.TfLiteInitializationOptions
import org.tensorflow.lite.InterpreterApi
import com.google.android.gms.tflite.gpu.support.TfLiteGpu
import com.google.android.gms.tflite.java.TfLite
import com.skripsi.malware_detection.R
import org.tensorflow.lite.gpu.GpuDelegateFactory
import java.io.FileInputStream
import java.io.IOException
import java.nio.ByteBuffer
import java.nio.MappedByteBuffer
import java.nio.channels.FileChannel

class AnnHelper(
    private val modelName: String = "ann_smote.tflite",
    val context: Context,
    private val onResult: (String) -> Unit,
    private val onError: (String) -> Unit
) {
    private var isGPUSupported: Boolean = false
    private var interpreter: InterpreterApi? = null

    init {
        TfLiteGpu.isGpuDelegateAvailable(context).onSuccessTask { gpuAvailable ->
            val optionsBuilder = TfLiteInitializationOptions.builder()
            if(gpuAvailable){
                optionsBuilder.setEnableGpuDelegateSupport(true)
                isGPUSupported = true
            }
            TfLite.initialize(context, optionsBuilder.build())
        }.addOnSuccessListener {
            loadLocalModel()
        }.addOnFailureListener {
            onError(context.getString(R.string.tflite_is_not_initialized_yet))
        }
    }

    private fun loadLocalModel(){
        try {
            val buffer: ByteBuffer = loadModelFile(context.assets, modelName)
            initializedInterpreter(buffer)
        }
        catch (ioException: IOException){
            ioException.printStackTrace()
        }
    }

    private fun loadModelFile(assetManager: AssetManager, modelPath: String): MappedByteBuffer {
        assetManager.openFd(modelPath).use { fileDescriptor ->
            FileInputStream(fileDescriptor.fileDescriptor).use { inputStream ->
                val fileChannel = inputStream.channel
                val startOffset = fileDescriptor.startOffset
                val declaredLength = fileDescriptor.declaredLength
                return fileChannel.map(FileChannel.MapMode.READ_ONLY, startOffset, declaredLength)
            }
        }
    }

    private fun initializedInterpreter(model: Any){
        interpreter?.close()
        try {
            val options = InterpreterApi.Options()
                .setRuntime(InterpreterApi.Options.TfLiteRuntime.FROM_SYSTEM_ONLY)
            if(isGPUSupported){
                options.addDelegateFactory(GpuDelegateFactory())
            }
            if(model is ByteBuffer){
                interpreter = InterpreterApi.create(model, options)
            }
        }
        catch (e: Exception){
            onError(e.message.toString())
            Log.e(TAG, e.message.toString())
        }
    }

    fun predict(inputFeature: FloatArray) {
        if (interpreter == null) return

        val inputArray = arrayOf(inputFeature)
        val outputArray = Array(1) { FloatArray(1) }

        try {
            interpreter?.run(inputArray, outputArray)

            val probability = outputArray[0][0]
            val result = interpreterResult(probability.toDouble())
            onResult(result)

        } catch (e: Exception) {
            onError(e.message ?: "Prediction failed")
            Log.e(TAG, "Prediction error", e)
        }
    }

    fun interpreterResult(probability: Double): String{
        val percent = probability * 100.0

        val label = if(probability >= 0.5){
            "Malware"
        }
        else{
            "Benign"
        }

        return buildString {
            append(label)
            append(" (")
            append(String.format("%.2f", percent))
            append("%)")
        }
    }

    fun close(){
        interpreter?.close()
    }

    companion object {
        private const val TAG = "AnnHelper"
    }
}