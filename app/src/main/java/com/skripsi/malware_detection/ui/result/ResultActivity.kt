package com.skripsi.malware_detection.ui.result

import android.annotation.SuppressLint
import android.os.Bundle
import android.util.Log
import android.view.View
import android.widget.Toast
import androidx.activity.enableEdgeToEdge
import androidx.activity.viewModels
import androidx.appcompat.app.AppCompatActivity
import androidx.core.view.ViewCompat
import androidx.core.view.WindowInsetsCompat
import com.skripsi.malware_detection.R
import com.skripsi.malware_detection.database.local.entity.ExtractionResultEntity
import com.skripsi.malware_detection.database.Result
import com.skripsi.malware_detection.databinding.ActivityResultBinding
import com.skripsi.malware_detection.helper.AnnHelper
import com.skripsi.malware_detection.ui.ExtractionResultModelFactory
import com.skripsi.malware_detection.util.Util

class ResultActivity : AppCompatActivity() {

    private var _binding: ActivityResultBinding? = null
    private val binding get() = _binding

    private var eid: String = ""
    private var apiCalled = false

    private val extractionResultModelFactory: ExtractionResultModelFactory by lazy {
        ExtractionResultModelFactory.getInstance(this)
    }

    private val resultViewModel: ResultViewModel by viewModels {
        extractionResultModelFactory
    }

    private lateinit var annHelper: AnnHelper

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()

        _binding = ActivityResultBinding.inflate(layoutInflater)
        setContentView(binding?.root)
        supportActionBar?.hide()

        eid = intent.getStringExtra(EID).toString()

        setupEdgetoEdge()
        fetchExtractionResult()
        setupInterpretButton()
        setupPredictionHelper()

    }

    private fun setupEdgetoEdge(){
        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets ->
            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())
            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)
            insets
        }
    }

    private fun fetchExtractionResult() {
        resultViewModel.getExtractionResultRoom(eid)
            .observe(this) { extraction ->
                if (extraction != null) {
                    showLoading(false)
                    editContent(extraction)
                }
                else {
                    fetchFromApi()
                }
            }
    }

    private fun setupInterpretButton(){
        binding?.btnInterpret?.setOnClickListener {
            resultViewModel.getExtractionResultRoom(eid).observe(this) { result ->
                val floatInput = result.pcaResult.map { it.toFloat() }.toFloatArray()
                annHelper.predict(floatInput)
            }
        }
    }

    private fun setupPredictionHelper(){
        annHelper = AnnHelper(
            context = this,
            onResult = { result ->
                binding?.tvRes?.text = result
            },
            onError = {errorMessage ->
                Toast.makeText(this, errorMessage, Toast.LENGTH_SHORT).show()
            }
        )
    }

    private fun editContent(extraction: ExtractionResultEntity){
        binding?.tvApkTitle?.text = extraction.apkName
        binding?.tvApkNameContent?.text = extraction.apkName
        binding?.tvApkSizeContent?.text = Util.formatFileSize(extraction.apkSize)
        binding?.tvStartTimeContent?.text = Util.formatTimestampString(extraction.startTime)
        binding?.tvEndTimeContent?.text = Util.formatTimestampString(extraction.endTime)
        binding?.tvExtrationDurationContent?.text = Util.formatSecond(extraction.extractionDuration)
    }

    private fun fetchFromApi(){
        if(apiCalled) return
        apiCalled = true

        resultViewModel.getExtractionResult(eid)

        resultViewModel.resultStatus.observe(this) { response ->
            when(response){
                is Result.Loading -> showLoading(true)
                is Result.Success -> {}
                is Result.Error -> handleFetchFail(response.error)
            }
        }
    }

    private fun handleFetchFail(error: String) {
        showLoading(false)
        Toast.makeText(this, error, Toast.LENGTH_SHORT).show()
    }

    private fun showLoading(isLoading: Boolean) {
        binding?.pgExtractionResult?.visibility = if(isLoading) View.VISIBLE else View.GONE
    }

    companion object{
        private const val EID = "extractionId"
    }
}